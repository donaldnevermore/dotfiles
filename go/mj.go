package mj

import (
	"crypto/rand"
	"fmt"
	"math/big"
)

func SampleMahjongShuffle() {
	// init cards
	mahjong := Cards{}
	mahjong.Reset()

	// shuffle card
	mahjong.Shuffle()

	// print
	fmt.Println(mahjong.Encode())
}

var CARDS = []int16{
	0x01, 0x01, 0x01, 0x01,
	0x02, 0x02, 0x02, 0x02,
	0x03, 0x03, 0x03, 0x03,
	0x04, 0x04, 0x04, 0x04,
	0x05, 0x05, 0x05, 0x105, // 0x105 0p
	0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08,
	0x09, 0x09, 0x09, 0x09, // 0x01~0x09 1~9p

	0x11, 0x11, 0x11, 0x11,
	0x12, 0x12, 0x12, 0x12,
	0x13, 0x13, 0x13, 0x13,
	0x14, 0x14, 0x14, 0x14,
	0x15, 0x15, 0x15, 0x115, // 0x115 1p
	0x16, 0x16, 0x16, 0x16,
	0x17, 0x17, 0x17, 0x17,
	0x18, 0x18, 0x18, 0x18,
	0x19, 0x19, 0x19, 0x19, // 0x11~0x19 1~9s

	0x21, 0x21, 0x21, 0x21,
	0x22, 0x22, 0x22, 0x22,
	0x23, 0x23, 0x23, 0x23,
	0x24, 0x24, 0x24, 0x24,
	0x25, 0x25, 0x25, 0x125, // 0x125 2p
	0x26, 0x26, 0x26, 0x26,
	0x27, 0x27, 0x27, 0x27,
	0x28, 0x28, 0x28, 0x28,
	0x29, 0x29, 0x29, 0x29, // 0x21~0x29 1~9m

	0x31, 0x31, 0x31, 0x31,
	0x41, 0x41, 0x41, 0x41,
	0x51, 0x51, 0x51, 0x51,
	0x61, 0x61, 0x61, 0x61,
	0x71, 0x71, 0x71, 0x71,
	0x81, 0x81, 0x81, 0x81,
	0x91, 0x91, 0x91, 0x91,
}

type Cards []int16

func (cs *Cards) Shuffle() {
	cardTotal := len(*cs)
	for i := cardTotal - 1; i > 0; i-- {
		index := i
		randValue, err := rand.Int(rand.Reader, big.NewInt(int64(i+1)))
		if err == nil {
			index = int(randValue.Int64())
		}
		(*cs)[i], (*cs)[index] = (*cs)[index], (*cs)[i]
	}
}

func (cs *Cards) Reset() {
	cardTotal := len(CARDS)
	*cs = make(Cards, cardTotal)
	copy(*cs, CARDS)
}

func (cs *Cards) Len() int {
	return len(*cs)
}

// encode to display
func (cs *Cards) Encode() string {
	encodes := make([]byte, 0, cs.Len()*2)
	for i := 0; i < cs.Len(); i++ {
		encodes = append(encodes, cardCode((*cs)[i])...)
	}
	return string(encodes)
}

func cardCode(card int16) []byte {
	code := make([]byte, 2, 2)
	if card <= 0x09 {
		code[0] = byte(card-0x00) + '0'
		code[1] = 'p'
	} else if card <= 0x19 {
		code[0] = byte(card-0x10) + '0'
		code[1] = 's'
	} else if card <= 0x29 {
		code[0] = byte(card-0x20) + '0'
		code[1] = 'm'
	} else if card <= 0x91 {
		code[0] = byte(card/16) - 2 + '0'
		code[1] = 'z'
	} else if card == 0x0105 {
		code[0] = '0'
		code[1] = 'p'
	} else if card == 0x0115 {
		code[0] = '0'
		code[1] = 's'
	} else if card == 0x0125 {
		code[0] = '0'
		code[1] = 'm'
	}
	return code
}
